#![feature(io_error_more)]
#![feature(async_closure)]
#![deny(unsafe_code)]

use std::fs;

use args::Arguments;
use clap::Parser;
use colour::*;
use diff::{diff, generate_single_header, PostProcessError};
use futures::future::join_all;
use table::create_table;
use tokio;
use unity_version::UnityVersion;
use version_parser::DownloadableUnity;

mod args;
mod diff;
mod downloader;
mod table;
mod unity_version;
mod version_parser;
mod writer;

async fn decompress_and_flush<'a>(unity_version: DownloadableUnity, buffer: Vec<u8>) -> Option<DownloadableUnity> {
    let writer = writer::LibIl2CppWriter::new(&unity_version.inner, buffer);
    cyan_ln!("Decompressing editor, this will take a while...");
    match writer.write() {
        Ok(_) => {
            green_ln!("✔ Successfully extracted libil2cpp source for {}", unity_version);
            Some(unity_version)
        }
        Err(e) => {
            red_ln!("✘ Failed to extract due {}", e);
            panic!();
        }
    }
}

async fn stage1(unity_versions: &mut Vec<DownloadableUnity>) {
    let unity201745f1 = UnityVersion::new(2017, Some(4), Some(5), Some('f'), Some(1));
    let unity201810b2 = UnityVersion::new(2018, Some(1), Some(0), Some('b'), Some(2));
    let unity201814f1 = UnityVersion::new(2018, Some(1), Some(4), Some('f'), Some(1));
    let unity201820b2 = UnityVersion::new(2018, Some(2), Some(0), Some('b'), Some(2));
    let unity201820b8 = UnityVersion::new(2018, Some(2), Some(0), Some('b'), Some(8));

    let mut tasks = vec![];
    for unity_version in unity_versions.iter_mut() {
        let inner = &unity_version.inner;

        if (*inner <= unity201745f1) || (*inner >= unity201810b2 && *inner <= unity201814f1) || (*inner >= unity201820b2 && *inner <= unity201820b8) {
            continue;
        }
        if std::path::Path::new(format!("{}/{}", inner.major, inner.version()).as_str()).exists() {
            green_ln!("✔ Already downloaded {}", inner);
            unity_version.is_downloaded = true;
            continue;
        }

        match downloader::is_available_for_linux(inner).await {
            Ok(true) => {}
            Ok(false) | Err(_) => {
                yellow_ln!("Skipping {} as it don't have linux editor", inner);
                continue;
            }
        }

        match downloader::download_using_changeset(&unity_version).await {
            Ok(buffer) => {
                let coro = decompress_and_flush(unity_version.clone(), buffer);
                // Usually download is slower than decompressing, unless you have 1GiB connection
                // Let's hope it won't reach OOM
                tasks.push(tokio::spawn(coro));
            }
            Err(e) => red_ln!(
                "✘ Failed to download due {} this usually means that unity have replaced this version with newer one",
                e
            ),
        }
    }
    if tasks.len() > 0 {
        yellow_ln_bold!("Suspending execution until decompression task will be finished");
        join_all(tasks.into_iter()).await.into_iter().for_each(|e| {
            if let Ok(Some(unity_version)) = e {
                let non_cloned = unity_versions.iter_mut().find(|u| **u == unity_version).unwrap();
                non_cloned.is_downloaded = true;
                println!("Marking {} as downloaded", non_cloned);
            }
        });
    }
}

fn stage2(unity_versions: &mut Vec<DownloadableUnity>) {
    unity_versions.iter_mut().for_each(|e| e.is_downloaded = true);
    let table = create_table(unity_versions)
        .map(|e| format!("<details><summary>Expand Unity {}</summary>\n\n{}</details>", e.0, e.1))
        .collect::<Vec<_>>()
        .join("\n");
    let md = format!(
        "This file was autogenerated by libil2cpp-parser.

{}",
        table
    );
    fs::write("VERSIONS.md", md).unwrap();
}

fn stage3(unity_versions: &Vec<DownloadableUnity>) {
    for unity_version in unity_versions {
        match generate_single_header(&unity_version.inner) {
            Ok(_) => {
                green_ln!("✔ Sucessfully preprocessed {} headers", unity_version)
            }
            Err(PostProcessError::NotDownloaded) => {
                yellow_ln_bold!("{} is not downloaded, not processing", unity_version)
            }
            Err(PostProcessError::AlreadyPreprocessed) => {}
            Err(PostProcessError::InvocationFailed) => {
                red_ln!("✘ Failed to invoke preprocessor for {}", unity_version)
            }
            Err(PostProcessError::NonUtf8Output) => {
                red_ln!("✘ Failed to parse preprocessor output due non-utf8 characters for {}", unity_version)
            }
        }
    }
    println!("Diffing headers...");
    diff();
}

#[tokio::main(flavor = "multi_thread", worker_threads = 4)]
async fn main() {
    let args = Arguments::parse();
    if let Ok(text) = downloader::fetch_archive().await {
        let mut unity_versions = version_parser::parse_unity_versions(&text);
        if args.stage_1 {
            println!("Stage 1: Downloading all available unity versions");
            stage1(&mut unity_versions).await;
        }

        if args.stage_2 {
            println!("Stage 2: Building markdown file");
            stage2(&mut unity_versions);
        }

        if args.stage_3 {
            println!("Stage 3: Building single-header IL2CPP structs and diffing 'em");
            stage3(&unity_versions);
        }
    }
}
